name: ðŸ•· Wordfence crawler (delta)

on:
  workflow_dispatch:

jobs:
  delta:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Python 3.10
        uses: actions/setup-python@v3
        with:
          python-version: "3.10"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          python - << 'PY'
import sys, json
print(sys.version)
PY

      - name: Prepare snapshot directory
        run: |
          mkdir -p data
          # Ensure previous snapshots exist (first run bootstrap)
          [ -f data/wordfence-prev.json ] || echo '[]' > data/wordfence-prev.json

      - name: Fetch Wordfence API snapshots (production + scanner)
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL https://www.wordfence.com/api/intelligence/v2/vulnerabilities/production -o data/prod.json
          curl -fsSL https://www.wordfence.com/api/intelligence/v2/vulnerabilities/scanner -o data/scan.json
          # Merge arrays into a single array snapshot
          python - << 'PY'
import json, sys
with open('data/prod.json') as f: prod = json.load(f)
with open('data/scan.json') as f: scan = json.load(f)
merged = (prod or []) + (scan or [])
# Normalize by a stable unique id (choose id or cve + plugin/theme slug)
# Keep full record; generator will decide paths
with open('data/wordfence-today.json', 'w') as f: json.dump(merged, f, sort_keys=True, ensure_ascii=False)
print(f"Merged entries: {len(merged)}")
PY

      - name: Compute delta (add/update/remove)
        shell: bash
        run: |
          set -euo pipefail
          python - << 'PY'
import json, hashlib

def key(rec):
    # Prefer stable unique key; use 'id' if present, else composite
    # Adjust to your actual schema:
    # id = rec.get('id') or f"{rec.get('cve')}-{rec.get('slug')}"
    idv = rec.get('id') or rec.get('cve') or rec.get('slug') or rec.get('name')
    return str(idv)

def digest(rec):
    # Stable digest for content equality; sort keys
    b = json.dumps(rec, sort_keys=True, ensure_ascii=False).encode('utf-8')
    return hashlib.sha256(b).hexdigest()

with open('data/wordfence-prev.json') as f:
    prev = json.load(f)
with open('data/wordfence-today.json') as f:
    today = json.load(f)

prev_map = {key(r): r for r in prev}
today_map = {key(r): r for r in today}

adds = []
updates = []
removes = []

for k, rec in today_map.items():
    if k not in prev_map:
        adds.append(rec)
    else:
        if digest(rec) != digest(prev_map[k]):
            updates.append(rec)

for k, rec in prev_map.items():
    if k not in today_map:
        removes.append(rec)

print(f"ADD: {len(adds)}, UPDATE: {len(updates)}, REMOVE: {len(removes)}")

with open('data/add.json', 'w') as f: json.dump(adds, f, sort_keys=True, ensure_ascii=False)
with open('data/update.json', 'w') as f: json.dump(updates, f, sort_keys=True, ensure_ascii=False)
with open('data/remove.json', 'w') as f: json.dump(removes, f, sort_keys=True, ensure_ascii=False)
PY

      - name: Generate templates for add/update only
        shell: bash
        run: |
          set -euo pipefail
          # Export files so main.py can read them if needed
          echo "Add count: $(jq length data/add.json)"
          echo "Update count: $(jq length data/update.json)"
          # Assuming main.py can take --json-input to process a list
          # If not, implement a thin adapter loop calling your existing generator by ID.
          if [ "$(jq length data/add.json)" != "0" ]; then
            python src/main.py --json-input data/add.json --tag production --no-clean --overwrite
          fi
          if [ "$(jq length data/update.json)" != "0" ]; then
            python src/main.py --json-input data/update.json --tag production --no-clean --overwrite
          fi

      - name: Remove templates for disappeared entries
        shell: bash
        run: |
          set -euo pipefail
          # Your Python can implement a remover for records in remove.json
          if [ "$(jq length data/remove.json)" != "0" ]; then
            python src/main.py --json-remove data/remove.json
          fi

      - name: Stage snapshot rotation
        run: |
          # Rotate snapshots: today -> prev for next run
          cp data/wordfence-today.json data/wordfence-prev.json
          git add data/wordfence-prev.json

      - name: Commit minimal delta changes
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config core.filemode false

          # Commit only if there are any staged or unstaged changes
          git add -A
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          # Optional: split by category; otherwise single summary commit
          ADDS=$(jq length data/add.json)
          UPDS=$(jq length data/update.json)
          RMS=$(jq length data/remove.json)
          git commit -m "chore(delta): add=${ADDS}, update=${UPDS}, remove=${RMS}"
          echo "Committed delta."
      
      - name: Push changes
        if: success()
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.SECRET_TOKEN }}
